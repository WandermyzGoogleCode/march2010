# 目录 #


# 问题 #
> 硬件有接口，接口可以被管理员或者网络所访问，因此枚举攻击总是能够被发起，只不过枚举攻击只能通过在线访问硬件完成，比离线攻击要安全。

# DECLARE #
> 现在的加密和安全模型好像无论如何都无法避免上述的问题（据我所知……）

# 现有模型 #
> 现在的安全加密模型基本可以总结为：构造一个HARD的PROBLEM，ATTACKER想要解决PROBLEM以获得需要的信息。ATTACKER可以进行一些攻击操作（比如枚举密钥），但是ATTACKER要解决PROBLEM需要进行足够多（一般为2<sup>100</sup>以上）的攻击操作，然而这样的操作在现有的环境下是不可能在有效时间内完成的。

# 模型失效 #
> 然而，在上述的模型下，如果PROBLEM本身难度的上限被限制住，那么上述的模型就没有安全性了。比如，在我们的应用中，PROBLEM的难度受手机号码的个数所限制，因此无论用如何牛的加密和HASH算法，10<sup>9</sup>个攻击操作（这个攻击操作和用户普通使用系统的操作其实是一样的，因此一定无法避免）就足以解决这个PROBLEM。

# 问题总结 #
> 在原有的模型中，只有两个主体：PROBLEM和ATTACKER。一个显然缺少的主题就是DEFENDER（如果一定说要有DEFENDER的话，那么上述模型的DEFENDER在构造完PROBLEM以后就消失了）。在没有DEFENDER的情况下，ATTACKER最终总是能够解决PROBLEM的，只不过时间长短的问题，只要给出足够长的时间，或者ATTACKER的攻击速度足够快，PROBLEM总是能被解决。

> 因此，现在的密钥的长度才总是需要加长，因为计算机的计算能力越来越强。而如果PROBLEM的难度受到了限制，那么一旦ATTACKER的攻击能力达到了这个限制，那么原有模型无论如何也无法保证安全性了。

# 新建模型： #
> 显然我们的新模型就是要引入DEFENDER这个角色。在具体描述DEFENDER之前，我们先在具体定义一下ATTACKER攻击PROBLEM的这个过程。

> 我们认为解决一个PROBLEM需要收集足够多的信息，比如初始时ATTACKER拥有的信息为0%，ATTACKER每发起一次攻击操作可以获取x的信息，一旦ATTACKER通过攻击操作积累到100％的信息，那么PROBLEM就被攻破了。对于暴力枚举攻击而言，x是一个常数，比如密钥的空间有2<sup>128</sup>这么大，那么每一次枚举密钥攻击获得的信息x就是1/2<sup>128</sup>。

> 简单的说，定义I\_n为ATTACKER在进行n次攻击操作以后获得的信息，如果只有ATTACKER的存在，那么`I_n = I_{n-1}+x_n，一旦I_n >= 1，那么ATTACKER就成功了。`

> 而如果有DEFENDER存在，DEFENDER可以进行一个防守操作使得攻击方获得的信息变少。简单的说，`I_n = f(I_{n-1}+x_n)，其中f表示一个削弱函数，比如f(x) = x/2。`

> 在以往的模型中，由于缺乏DEFENDER，因此一旦由于PROBLEM本身的限制使得ATTACKER在每一次攻击中获得的信息x\_i足够大，那么I\_n总是会很快的达到1。但是，引入了DEFENDER以后，虽然x\_i足够大，但是f的存在会平衡其增加的信息量，一旦f比x\_i更为强大，那么I\_n永远都无法达到1，不管ATTACKER发起多少次攻击。这样一来，整个安全措施就不会因为计算能力的增强而需要变化，因为ATTACKER边强，DEFENDER会变得更强。

> 举个例子，假设x\_i = 1/3，即在原有的模型中ATTACKER攻击三次就能解决PROBLEM了。但是如果DEFENDER的能力是f(x) = x/2，那么我们得到`I_n = (I_{n-1}+1/3)/2, I_0 = 0.`
> 即`I_n = I_{n-1}/2+1/6`，可以通过归纳法证明I\_n <= 1/3。因此，ATTACKER永远都无法攻破PROBLEM。

# 我们的应用： #
> 在我们的应用中，由于手机号码有限，因此可知ATTACKER的每次攻击至少可以获得x = 1/10<sup>9</sup>的信息，因此在原有的模型中ATTACKER通过10<sup>9</sup>调用硬件的HASH计算功能就能够攻破PROBLEM，反向还原出所有的号码。

> 我们引入的DEFENDER就是要破坏ATTACKER通过暴力枚举计算HASH值获得的信息。一个理想的DEFENDER就是更新硬件中的私钥，使得以前的HASH值全部失效，这样f(x) = 0。然而这样做是不现实的，因为我们还要保证系统的正常运行，用户应该能够继续访问以前建立起来的索引信息。而一旦我们对数据库中的每一个HASH值进行逐个更新的时候，那么ATTACKER可能在一旁监视更新，从而得到旧HASH值到新HASH值的映射，这样一来f(x) = x，DEFENDER什么也没有干。

> 因此，我们改进DEFENDER，比如将数据库中所有的索引项全部都送进硬件，硬件对所有的索引项进行全部更新以后统一写入数据库。这样，如果数据库中有N个项的话，那么输入和输出的对应关系就有N！种，这个对应关系是ATTACKER所不知道的。此时，f(x) = x/N!（没有严格证明过，这个需要对具体的PROBLEM以及ATTACKER的攻击方法进行计算）。

> 然而上述的策略对硬件来说不现实，因为需要加密硬件能有存储N个索引项，但是这个N是巨大的。

> 一个更经济的实现就是一次给硬件两个索引项，硬件输出两个重新加密的索引项。如此一来，ATTACKER就无法区分两个索引项之间的对应关系，如果我们对所有的索引项都进行这样两两的操作，那么我们认为f(x) = x/2（没有严格证明过，这个需要对具体的PROBLEM以及ATTACKER的攻击方法进行计算。其中一个例子就是如果进行交换的两个元素如果可以由ATTACKER选定，那么f(x) = x/2就失效了，因为ATTACKER总是让硬件交换两个指定的索引）。

# 更具体的问题 #
> 上述对于我们的应用中，认为ATTACKER要解决的PROBLEM是哪个HASH值对应哪个号码。

> 然而上述的问题并不一定是ATTACKER唯一想要攻击的。另一个PROBLEM可能就是系统中拥有哪些号码。这样的攻击也是很致命的，比如这个系统一开始只在清华运行，那么一旦这个攻击成功，ATTACKER就获得了所有清华的号码……

> 而对于这样的PROBLEM和ATTACKER，上述的DEFENDER显然没有任何作用，即f(x) = x，因为不论怎么换序，在系统中就是在系统中，不在系统中就是不在系统中。

> 为此，我们可以引入一个机制以加强我们的DEFENDER：往系统中加入M个不存在的索引项，那么ATTACKER在攻击时就无法知道算出的HASH值到底是属于真实的N个索引项还是假的M个索引项，而又由于前面的结论，ATTACKER无法跟踪HASH值和号码之间的对应关系，因此DEFENDER再一次成功削弱了ATTACKER的攻击。

# 总结 #
> 在新的模型中，我们首先定义出ATTACKER，ATTACKER所面临的PROBLEM以及ATTACKER攻击的方式，`即抽象出I_n = I_{n-1}+x_n（更一般的，可以认为I_n = g(I_{n-1}))。`

> 然后针对攻击，我们设置一个DEFENDER，削弱ATTACKER获得的信息，`即I_n = f(I_{n-1}+x_n).`

> 最终只要证明I\_n的上界很小，就能证明系统对于此类ATTACKER和PROBLEM的安全性。

# 附源文件 #
  * [hardware.h](http://code.google.com/p/march2010/source/browse/trunk/hardware/hardware.h)
> > 上述源文件简单的定义了一个硬件的接口，根据新的安全模型实现了我们的应用。